# [[cc.block.metadata]]
'''
File: code_patcher_cli.py
Version: 1.2.0
Last Updated: 2024-09-30
Description: CLI tool for applying CogniCoder-generated patches using CML parsing
'''
# [[/cc.block.metadata]]

# [[cc.block.imports]]
import os
import click
from datetime import datetime
from cml_parser import CMLParser
from typing import List, Tuple
# [[/cc.block.imports]]

# [[cc.block.constants]]
PATCHED_EXTENSION = ".PATCHED"
# [[/cc.block.constants]]

# [[cc.block.class.CodePatcherCML]]
class CodePatcherCML:
    """Enhanced CodePatcherCML class for applying patches generated by CogniCoder using CML parsing."""

    # [[cc.block.method.init]]
    def __init__(self, original_file: str, patch_file: str):
        """
        Initialize the CodePatcherCML.

        Args:
            original_file (str): Path to the original file.
            patch_file (str): Path to the patch file.
        """
        self.original_file = original_file
        self.patch_file = patch_file
        self.cml_parser = CMLParser()
        self.patch_content = self._load_patch_file()
    # [[/cc.block.method.init]]

    # [[cc.block.method.load_patch_file]]
    def _load_patch_file(self) -> List[Tuple[str, str]]:
        """Load and parse the patch file content."""
        try:
            with open(self.patch_file, 'r') as f:
                patch_content = f.read()
            return self.cml_parser.parse_content(patch_content)['block']
        except Exception as e:
            raise click.ClickException(f"Error loading patch file: {str(e)}")
    # [[/cc.block.method.load_patch_file]]

    # [[cc.block.method.apply_patch]]
    def apply_patch(self):
        """Apply the patch to create a new patched file."""
        if not os.path.exists(self.original_file):
            raise FileNotFoundError(f"Original file not found: {self.original_file}")

        try:
            with open(self.original_file, 'r') as f:
                original_content = f.read()

            patched_content = self._process_patch(original_content)

            patched_file = f"{self.original_file}{PATCHED_EXTENSION}"
            with open(patched_file, 'w') as f:
                f.write(patched_content)

            click.echo(f"Successfully created patched file: {patched_file}")
        except Exception as e:
            raise click.ClickException(f"Error applying patch: {str(e)}")
    # [[/cc.block.method.apply_patch]]

    # [[cc.block.method.process_patch]]
    def _process_patch(self, original_content: str) -> str:
        """Process the patch and apply changes to the original content."""
        patched_content = original_content

        for block_type, block_content in self.patch_content:
            if 'remove' in block_type:
                patched_content = self._remove_block(patched_content, block_type.replace('remove.', ''))
            else:
                patched_content = self._add_or_replace_block(patched_content, block_type, block_content)

        return patched_content
    # [[/cc.block.method.process_patch]]

    # [[cc.block.method.add_or_replace_block]]
    def _add_or_replace_block(self, content: str, block_type: str, block_content: str) -> str:
        """Add or replace a block in the content."""
        block_start = f"# [[cc.block.{block_type}]]"
        block_end = f"# [[/cc.block.{block_type}]]"
        
        start_index = content.find(block_start)
        end_index = content.find(block_end)

        if start_index != -1 and end_index != -1:
            # Replace existing block
            return (
                content[:start_index] +
                f"{block_start}\n{block_content}\n{block_end}" +
                content[end_index + len(block_end):]
            )
        else:
            # Add new block
            return f"{content}\n\n{block_start}\n{block_content}\n{block_end}"
    # [[/cc.block.method.add_or_replace_block]]

    # [[cc.block.method.remove_block]]
    def _remove_block(self, content: str, block_type: str) -> str:
        """Remove a block from the content."""
        block_start = f"# [[cc.block.{block_type}]]"
        block_end = f"# [[/cc.block.{block_type}]]"
        
        start_index = content.find(block_start)
        end_index = content.find(block_end)

        if start_index != -1 and end_index != -1:
            return content[:start_index] + content[end_index + len(block_end):]
        
        return content
    # [[/cc.block.method.remove_block]]

    # [[cc.block.method.patch_from_string]]
    def patch_from_string(self, original_content: str, patch_content: str) -> str:
        """
        Apply a patch directly from string content.

        Args:
            original_content (str): The original file content as a string.
            patch_content (str): The patch content as a string.

        Returns:
            str: The patched content.
        """
        try:
            parsed_patch = self.cml_parser.parse_content(patch_content)['block']
            self.patch_content = parsed_patch
            return self._process_patch(original_content)
        except Exception as e:
            raise click.ClickException(f"Error applying patch from string: {str(e)}")
    # [[/cc.block.method.patch_from_string]]

    # [[cc.block.method.generate_patch]]
    def generate_patch(self, blocks: List[Tuple[str, str]]) -> str:
        """
        Generate a patch file content from a list of CML blocks.

        Args:
            blocks (List[Tuple[str, str]]): A list of tuples containing block types and content.

        Returns:
            str: The generated patch file content.
        """
        patch_content = ""
        for block_type, block_content in blocks:
            patch_content += self.cml_parser.generate_cml_block('block', block_type, block_content) + "\n\n"
        return patch_content.strip()
    # [[/cc.block.method.generate_patch]]

    # [[cc.block.method.merge_patches]]
    def merge_patches(self, patch_files: List[str]) -> List[Tuple[str, str]]:
        """
        Merge multiple patch files.

        Args:
            patch_files (List[str]): A list of patch file paths.

        Returns:
            List[Tuple[str, str]]: A merged list of CML blocks.
        """
        block_lists = []
        for patch_file in patch_files:
            with open(patch_file, 'r') as f:
                patch_content = f.read()
            block_lists.append(self.cml_parser.parse_content(patch_content)['block'])
        return self.cml_parser.merge_block_lists(block_lists)
    # [[/cc.block.method.merge_patches]]

# [[/cc.block.class.CodePatcherCML]]

# [[cc.block.main]]
@click.command()
@click.option('--original', required=True, type=click.Path(exists=True), help='Path to the original file to be patched.')
@click.option('--patch', required=True, type=click.Path(exists=True), help='Path to the patch file.')
def apply_patch(original, patch):
    """Apply a CogniCoder-generated patch to create a new patched file using CML parsing."""
    try:
        patcher = CodePatcherCML(original, patch)
        patcher.apply_patch()
    except Exception as e:
        raise click.ClickException(str(e))

if __name__ == '__main__':
    apply_patch()
# [[/cc.block.main]]